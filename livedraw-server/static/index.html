<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>livedraw</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=VT323&display=swap"
      rel="stylesheet"
    />
    <style>
      @import url("https://fonts.googleapis.com/css2?family=VT323&display=swap");
      * {
        box-sizing: border-box;
      }
      html,
      body {
        padding: 0;
        margin: 0;
        font-family: "VT323", monospace;
        font-size: 24px;
        color: var(--color-main);
      }
      code {
        font-family: "VT323", monospace;
      }
      #main {
        position: relative;
        width: 1920px;
        height: 1080px;
        overflow: hidden;
      }
      #background {
        -webkit-mask-image: url("mask.svg");
        -webkit-mask-size: 100%;
        -webkit-mask-clip: border-box;
        background-image: var(--bg);
        position: absolute;
        width: 100%;
        height: 100%;
        z-index: -1;
      }
      #instructions {
        filter: drop-shadow(0px 1px 4px var(--color-main));
      }
      #chatbox {
        position: absolute;
        width: 38%;
        top: 5%;
        right: 5%;
        height: 40%;
        padding: 8px;
        background: #00000033;
        font-size: 1em;
        overflow-y: hidden;
      }
      .chat ul {
        list-style: none;
        margin: 0;
        padding: 0;
      }
      .chat li {
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
        padding: 2px 0;
        filter: drop-shadow(0px 0px 4px var(--color-main));
      }
      .chat li[data-fade-out] {
        content: "";
        opacity: 0.5;
        transition: all 5s ease-in-out;
      }
      #components {
        position: absolute;
        width: 55%;
        bottom: 0;
        right: 2%;
        height: 50%;
        padding: 0px;
        display: flex;
        flex-direction: column;
        justify-content: space-around;
      }
      #components > * {
        flex: 1;
        justify-content: space-evenly !important;
      }
      path {
        stroke: var(--color-main);
        transition: 500ms;
      }
      text {
        fill: var(--color-main);
      }
      #plot-camera {
        position: absolute;
        top: 50px;
        left: 50px;
        width: 705px;
        height: 940px;
      }
      #footer {
        position: absolute;
        bottom: 20px;
        left: 60px;
        width: 705px;
        color: var(--color-main);
        font-size: 1em;
        text-transform: uppercase;
        text-align: center;
        filter: drop-shadow(0px 0px 2px var(--color-main));
      }
      #pen-camera {
        position: absolute;
        top: 50px;
        left: 820px;
        width: 200px;
        height: 200px;
      }
      #streamer-camera {
        position: absolute;
        top: 280px;
        left: 820px;
        width: 200px;
        height: 200px;
        border-color: var(--color-live);
      }
      .camera {
        border: 4px solid var(--color-main);
        background-image: var(--camera-highlight);
      }
      .camera.disabled {
        border-color: var(--color-disabled);
        background-image: var(--camera-highlight-disabled);
        transition: 1s filter;
      }
      .camera.countdownpause {
        filter: hue-rotate(160deg);
      }
      .camera {
        display: flex;
        align-items: center;
        justify-content: center;
        flex-direction: column;
      }

      .camera .live {
        position: absolute;
        top: 1px;
        left: 4px;
        color: var(--color-live);
        text-transform: uppercase;
        font-size: 0.6em;
      }
      .blink {
        animation: blink 1s linear infinite;
      }
      @keyframes blink {
        50% {
          opacity: 1;
        }
        60%,
        90% {
          opacity: 0;
        }
      }
      .camera .countdown-pause-text {
      }
      .camera .countdown {
        margin: 10px;
        font-size: 1.4em;
      }
      #predictive {
        position: absolute;
        width: 96%;
        height: 96%;
        top: 2%;
        left: 2%;
      }
      #predictive .camera:not(.disabled) {
        animation: predictive infinite 2s;
      }
      #predictive.darkblue {
        opacity: 0.5;
        filter: invert(41%) sepia(69%) saturate(737%) hue-rotate(156deg)
          brightness(92%) contrast(93%);
      }
      #predictive.light {
        opacity: 0.5;
        filter: invert(76%) sepia(23%) saturate(658%) hue-rotate(185deg)
          brightness(100%) contrast(102%);
      }
      #predictive.debug-preview {
        opacity: 1;
        background: white;
      }
      @keyframes predictive {
        0%,
        100% {
          opacity: 0.5;
        }
        50% {
          opacity: 0.2;
        }
      }
      @keyframes loading {
        0%,
        100% {
          opacity: 0.4;
        }
        50% {
          opacity: 0.1;
        }
      }

      .mode-frozen #components {
        filter: brightness(200%) opacity(0.5);
      }

      .mode-berserk #components {
        animation: huerotate100 0.5s linear infinite;
      }
      @keyframes huerotate100 {
        0%,
        100% {
          filter: hue-rotate(0deg);
        }
        50% {
          filter: hue-rotate(100deg);
        }
      }

      .layout-input {
        margin: 8px 16px;
      }

      .layout-input-component-Poll {
        flex: 1;
      }

      .layout-input {
        transition: 0s;
        opacity: 1;
        filter: drop-shadow(0px 0px 2px var(--color-main));
      }
      .layout-input.layout-input-noupdates {
        transition: 1s;
        opacity: 0.8;
        filter: drop-shadow(0px 0px 6px var(--color-main));
      }

      .component-counter-btn {
        color: var(--color-main);
        border: 2px solid var(--color-main);
        border-radius: 2px;
        padding: 0.4em 1em;
        position: relative;
      }
      .component-counter-btn::before {
        background: var(--color-main);
        opacity: 0;
        content: "";
        width: 100%;
        height: 100%;
        top: 0;
        left: 0;
        position: absolute;
        transition: opacity 0.2s;
      }
      .component-counter-btn.active::before {
        opacity: 0.3;
        transition: opacity 0.1s;
      }

      .component-poll {
        color: var(--color-main);
      }
      .component-poll .question {
        font-weight: 400;
        text-transform: uppercase;
        font-size: 1em;
        margin-bottom: 0.4em;
        display: block;
      }
      .component-poll .choices {
      }
      .component-poll .choice {
        padding: 8px;
        border: var(--color-main) 1px solid;
        position: relative;
      }
      .component-poll .choices .choice:not(:last-child) {
        border-bottom: 0px;
      }

      .component-poll .choice .text {
        display: flex;
        flex-direction: row;
        justify-content: space-between;
      }
      .component-poll .choice .percent {
        position: absolute;
        height: 100%;
        left: 0;
        top: 0;
        opacity: 0.3;
        background-color: var(--color-main);
      }
      .component-poll .choice .label {
        text-transform: uppercase;
      }

      .component-range-vslider {
        text-align: center;
        line-height: 1.5em;
      }
      .component-range-vslider .label {
        text-transform: uppercase;
        font-size: 1em;
      }
      .component-range-vslider .slider {
        position: relative;
        border: 1px solid var(--color-main);
      }
      .component-range-vslider .percent {
        position: absolute;
        width: 100%;
        bottom: 0;
        opacity: 0.3;
        background-color: var(--color-main);
      }
      .component-range-vslider.loading .percent {
        animation: infinite 2s loading;
      }
      .component-range-vslider .target {
        position: absolute;
        width: 110%;
        left: -5%;
        border: 1px dashed var(--color-main);
      }
      .component-range-vslider .current {
        position: absolute;
        width: 110%;
        left: -5%;
        border: 1px solid var(--color-main);
      }

      .component-range-hslider {
        text-align: center;
        line-height: 1.5em;
      }
      .component-range-hslider .label {
        text-transform: uppercase;
        font-size: 1em;
        padding-bottom: 4px;
        display: block;
      }
      .component-range-hslider .slider {
        position: relative;
        border: 1px solid var(--color-main);
      }
      .component-range-hslider .percent {
        position: absolute;
        height: 100%;
        left: 0;
        opacity: 0.3;
        background-color: var(--color-main);
      }
      .component-range-hslider.loading .percent {
        animation: infinite 2s loading;
      }
      .component-range-hslider .target {
        position: absolute;
        height: 110%;
        top: -5%;
        border: 1px dashed var(--color-main);
      }
      .component-range-hslider .current {
        position: absolute;
        height: 110%;
        top: -5%;
        border: 1px solid var(--color-main);
      }

      .component-xy {
        text-align: center;
      }
      .component-xy .label {
        text-transform: uppercase;
        font-size: 1em;
        padding-bottom: 4px;
        display: block;
      }
      .component-xy .content {
        position: relative;
        border: 1px dashed var(--color-main);
      }
      .component-xy .current {
        position: absolute;
        background-color: var(--color-main);
      }
      .component-xy .target {
        position: absolute;
        background-color: var(--color-main);
        opacity: 0.3;
      }

      #plot-progress {
        position: absolute;
        left: 50px;
        bottom: 50px;
        width: 705px;
      }

      .progress-bar {
        width: 100%;
        height: 20px;
        border: 2px solid var(--color-main);
        overflow: hidden;
      }

      .progress-bar .progress {
        height: 100%;
        background-color: var(--color-main);
        transition: width 0.3s;
      }

      .progress-bar .progress.dashed {
        background-image: repeating-linear-gradient(
          to right,
          transparent,
          transparent 3px,
          #000 3px,
          #000 6px
        );
        background-size: 12px 6px;
      }

      .camtimer {
        color: var(--color-live);
        position: absolute;
        bottom: 2px;
        right: 2px;
        font-size: 0.8em;
      }

      #instructions {
        position: absolute;
        top: 47%;
        right: 2%;
        width: 55%;
        height: 30px;
        overflow: hidden;
        font-size: 1em;
        -webkit-mask-image: linear-gradient(
          to left,
          rgba(0, 0, 0, 0),
          rgba(0, 0, 0, 0.6),
          rgba(0, 0, 0, 0)
        );
      }

      .progressing {
        position: absolute;
        width: 100%;
        border-bottom: 1px dashed var(--color-main);
        opacity: 0.8;
        animation: move 1s linear infinite;
      }

      @keyframes move {
        from {
          transform: translateY(0);
        }
        to {
          transform: translateY(-100%);
        }
      }

      .progressing.down {
        animation-direction: reverse;
      }

      #instructions .content {
        display: inline-block;
        white-space: pre;
        animation: scroll 30s cubic-bezier(0, 0.2, 1, 0.8) infinite;
      }

      @keyframes scroll {
        from {
          transform: translateX(80%);
        }
        to {
          transform: translateX(-100%);
        }
      }
    </style>
  </head>
  <body>
    <div id="main"></div>
    <script src="https://unpkg.com/react/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/babel-standalone/babel.min.js"></script>
    <script type="text/babel">
      const { useState, useEffect, useMemo, useRef } = React;

      function CurveLinearImpl({ value, width, height, config }) {
        const pad = 10;
        const stepx = width / value.length;
        const yamp = height - 2 * pad;
        const d = value
          .map(
            (v, i) =>
              (i === 0 ? "M" : "L") +
              ((i + 0.5) * stepx).toFixed(2) +
              "," +
              (yamp * (1 - v) + pad).toFixed(2)
          )
          .join(" ");
        return (
          <g>
            <path
              d={d}
              fill="none"
              strokeWidth={2}
              strokeLinecap="round"
              strokeLinejoin="round"
            />
            <path
              d={`M0,${height / 2} L${width},${height / 2}`}
              fill="none"
              strokeWidth={0.5}
              strokeDasharray="0 4 0"
            />

            {config.letters.split("").map((v, i) => {
              const x = (((i + 0.5) * width) / config.letters.length).toFixed(
                1
              );
              return (
                <path
                  key={i}
                  d={`M${x},${0} L${x},${height}`}
                  fill="none"
                  strokeWidth={0.3}
                />
              );
            })}
          </g>
        );
      }

      const CurveLinear = React.memo(CurveLinearImpl);

      const AlphabetLinear = React.memo(function AlphabetLinearImpl({
        width,
        value,
        config,
      }) {
        return (
          <g>
            {config.letters.split("").map((l, i) => (
              <text
                key={i}
                fontFamily="monospace"
                fontSize="14px"
                dominantBaseline="middle"
                textAnchor="middle"
                x={((i + 0.5) * width) / config.letters.length}
                y={5}
                opacity={0.4 + 0.8 * value[i]}
              >
                {l}
              </text>
            ))}
          </g>
        );
      });

      function KeyboardCurveLinear({ value, config }) {
        const width = 400;
        const height = 100;
        const curveheight = 80;
        return (
          <svg width="100%" height="100%" viewBox={`0 0 ${width} ${height}`}>
            <CurveLinear
              value={value}
              width={width}
              height={curveheight}
              config={config}
            />
            <g transform="translate(0,80)">
              <AlphabetLinear width={width} value={value} config={config} />
            </g>
          </svg>
        );
      }

      function useProjectPolar(size, width, height) {
        return useMemo(() => {
          const rad = (0.9 * Math.min(width, height)) / 2;
          return (index, v) => {
            const angle = (index / size) * 2 * Math.PI;
            let r = 0.1 + 0.9 * v;
            const x = width / 2 + Math.cos(angle) * r * rad;
            const y = height / 2 + Math.sin(angle) * r * rad;
            return [x.toFixed(2), y.toFixed(2)];
          };
        }, [size, width, height]);
      }

      function circ(array) {
        return array.concat([array[0].replace("M", "L")]);
      }

      function CurvePolarStaticImpl({
        valueLength,
        res,
        letters,
        projectPolar,
      }) {
        let arr = Array(valueLength).fill(0);
        const halfD = circ(
          arr.map((_v, i) => (i === 0 ? "M" : "L") + projectPolar(i + 0.5, 0.5))
        ).join(" ");
        const fullD = circ(
          arr.map((_v, i) => (i === 0 ? "M" : "L") + projectPolar(i + 0.5, 1))
        ).join(" ");
        return (
          <g>
            <path
              d={halfD}
              fill="none"
              strokeWidth={0.5}
              strokeDasharray="0 4 0"
            />
            <path d={fullD} fill="none" strokeWidth={0.5} opacity={0.5} />
            {letters.split("").map((l, i) => {
              const pos = projectPolar(i * res, 1);
              const posFar = projectPolar(i * res, 1.05);
              return (
                <g key={i}>
                  <path
                    d={`M${projectPolar(i, 0)} L${pos}`}
                    fill="none"
                    strokeWidth={0.3}
                  />
                  <text
                    fontFamily="monospace"
                    fontSize="28px"
                    dominantBaseline="middle"
                    textAnchor="middle"
                    x={posFar[0]}
                    y={posFar[1]}
                    opacity={0.5}
                  >
                    {l}
                  </text>
                </g>
              );
            })}
          </g>
        );
      }

      const CurvePolarStatic = React.memo(CurvePolarStaticImpl);

      function CurvePolarImpl({ value, width, height, config }) {
        const projectPolar = useProjectPolar(value.length, width, height);

        const valueD = circ(
          value.map((v, i) => (i === 0 ? "M" : "L") + projectPolar(i + 0.5, v))
        ).join(" ");

        return (
          <g>
            <path
              d={valueD}
              fill="none"
              strokeWidth={2}
              strokeLinecap="round"
              strokeLinejoin="round"
            />

            <CurvePolarStatic
              projectPolar={projectPolar}
              res={config.resolution || 1}
              letters={config.letters}
              valueLength={value.length}
            />
          </g>
        );
      }
      const CurvePolar = React.memo(CurvePolarImpl);

      function KeyboardCurvePolar({ value, config }) {
        const width = 400;
        const height = 400;
        return (
          <svg width="100%" height="100%" viewBox={`0 0 ${width} ${height}`}>
            <CurvePolar
              value={value}
              width={width}
              height={height}
              config={config}
            />
          </svg>
        );
      }

      function KeyboardCurve({ value, config }) {
        return config.projection === "polar" ? (
          <KeyboardCurvePolar value={value} config={config} />
        ) : (
          <KeyboardCurveLinear value={value} config={config} />
        );
      }

      function Poll({ id, value, config }) {
        let sum = 0;
        value.scores.forEach(([k, v]) => {
          sum += v;
        });
        return (
          <div className="component-poll">
            <strong className="question">{config.question}</strong>
            <div className="choices">
              {Object.entries(config.choices).map(([key, label]) => (
                <div className="choice" key={key}>
                  <span className="text">
                    <code>
                      !{id} {key}
                    </code>
                    <span className="label">{label}</span>
                  </span>
                  {sum > 0 ? (
                    <div
                      className="percent"
                      style={{
                        width:
                          (
                            (100 *
                              (value.scores.find(([k]) => k === key) || [
                                key,
                                0,
                              ])[1]) /
                            sum
                          ).toFixed(1) + "%",
                      }}
                    />
                  ) : null}
                </div>
              ))}
            </div>
          </div>
        );
      }

      function CounterBtn({ id, value, config, style }) {
        const { min, max, display } = config;
        const scale = config.scale || style.inputsScale || 1;

        const [noupdates, setNoupdates] = useState(true);
        useEffect(() => {
          setNoupdates(false);
          const t = setTimeout(() => setNoupdates(true), 200);
          return () => clearTimeout(t);
        }, [value.value]);

        return (
          <span
            className={"component-counter-btn" + (!noupdates ? " active" : "")}
            style={{ fontSize: scale + "em" }}
          >
            !{id}
          </span>
        );
      }

      function Range({ id, value, config, style }) {
        const { min, max, display, styleScale } = config;
        const scale = styleScale || (style && style.inputsScale) || 1;
        const sizeL = 148 * scale;
        const sizel = 64 * scale;

        if (display === "vslider") {
          return (
            <div
              className={
                "component-range-vslider" +
                (value.value === value.target ? "" : " loading")
              }
            >
              <span className="label">!{id}</span>
              <div className="slider" style={{ width: sizel, height: sizeL }}>
                <div
                  className="percent"
                  style={{
                    height:
                      ((100 * (value.value - min)) / (max - min)).toFixed(1) +
                      "%",
                  }}
                />
                <div
                  className="current"
                  style={{
                    bottom:
                      ((100 * (value.value - min)) / (max - min)).toFixed(1) +
                      "%",
                  }}
                />
                {value.value === value.target ? null : (
                  <div
                    className={
                      "progressing " +
                      (value.value < value.target ? "up" : "down")
                    }
                    style={{
                      bottom:
                        (
                          (100 * (Math.min(value.target, value.value) - min)) /
                          (max - min)
                        ).toFixed(1) + "%",
                      height:
                        (
                          (100 * Math.abs(value.value - value.target)) /
                          (max - min)
                        ).toFixed(1) + "%",
                    }}
                  >
                    <div className="line" />
                  </div>
                )}
                {value.value === value.target ? null : (
                  <div
                    className="target"
                    style={{
                      bottom:
                        ((100 * (value.target - min)) / (max - min)).toFixed(
                          1
                        ) + "%",
                    }}
                  />
                )}
              </div>

              <span className="value">
                {config.format === "percentage"
                  ? (value.value * 100).toFixed(
                      typeof config.magnitude === "number"
                        ? config.magnitude
                        : 0
                    ) + "%"
                  : value.value.toFixed(
                      typeof config.magnitude === "number"
                        ? config.magnitude
                        : 1
                    )}
              </span>
            </div>
          );
        } else if (display === "hslider") {
          return (
            <div
              className={
                "component-range-hslider" +
                (value.value === value.target ? "" : " loading")
              }
            >
              <span className="label">!{id}</span>
              <div className="slider" style={{ width: sizeL, height: sizel }}>
                <div
                  className="percent"
                  style={{
                    width:
                      ((100 * (value.value - min)) / (max - min)).toFixed(1) +
                      "%",
                  }}
                />
                <div
                  className="current"
                  style={{
                    left:
                      ((100 * (value.value - min)) / (max - min)).toFixed(1) +
                      "%",
                  }}
                />
                {value.value === value.target ? null : (
                  <div
                    className={
                      "progressing " +
                      (value.value < value.target ? "right" : "left")
                    }
                    style={{
                      left:
                        (
                          (100 * (Math.min(value.target, value.value) - min)) /
                          (max - min)
                        ).toFixed(1) + "%",
                      width:
                        (
                          (100 * Math.abs(value.value - value.target)) /
                          (max - min)
                        ).toFixed(1) + "%",
                    }}
                  >
                    <div className="line" />
                  </div>
                )}
                {value.value === value.target ? null : (
                  <div
                    className="target"
                    style={{
                      left:
                        ((100 * (value.target - min)) / (max - min)).toFixed(
                          1
                        ) + "%",
                    }}
                  />
                )}
              </div>
              <span className="value">
                {config.format === "percentage"
                  ? (value.value * 100).toFixed(config.magnitude || 0) + "%"
                  : value.value.toFixed(config.magnitude || 1)}
              </span>
            </div>
          );
        }

        return null;
      }

      function XY({ id, value, config, style }) {
        const { styleScale } = config;
        const eq =
          value.value[0] === value.target[0] &&
          value.value[1] === value.target[1];
        const scale = styleScale || (style && style.inputsScale) || 1;
        const size = 148 * scale;
        const r = config.range || [-1, 1];
        function toNorm(v) {
          return lerp(r[0], r[1], v);
        }
        return (
          <div className={"component-xy" + (eq ? "" : " loading")}>
            <span className="label">{id}</span>
            <div className="content" style={{ width: size, height: size }}>
              <div
                className="current"
                style={{
                  height: "100%",
                  width: "2px",
                  left: (100 * toNorm(value.value[0])).toFixed(1) + "%",
                }}
              />
              <div
                className="current"
                style={{
                  width: "100%",
                  height: "2px",
                  top: (100 * toNorm(value.value[1])).toFixed(1) + "%",
                }}
              />
              {eq ? null : (
                <div>
                  <div
                    className="target"
                    style={{
                      height: "100%",
                      width: "2px",
                      left: (100 * toNorm(value.target[0])).toFixed(1) + "%",
                    }}
                  />
                  <div
                    className="target"
                    style={{
                      width: "100%",
                      height: "2px",
                      top: (100 * toNorm(value.target[1])).toFixed(1) + "%",
                    }}
                  />
                  <svg width={size} height={size}>
                    <path
                      d={`M${value.value
                        .map((v) => toNorm(v) * size)
                        .join(",")} L${value.target
                        .map((v) => toNorm(v) * size)
                        .join(",")}`}
                      stroke-width="1"
                      fill="none"
                      strokeDasharray="5,5"
                      strokeDashoffset="0"
                      style={{ transition: "none" }}
                    >
                      <animate
                        attributeName="stroke-dashoffset"
                        from="10"
                        to="0"
                        dur="0.5s"
                        repeatCount="indefinite"
                      />
                    </path>
                  </svg>
                </div>
              )}
            </div>
          </div>
        );
      }

      const components = {
        KeyboardCurve: React.memo(KeyboardCurve),
        Poll: React.memo(Poll),
        Range: React.memo(Range),
        XY: React.memo(XY),
        CounterBtn: React.memo(CounterBtn),
      };

      const LayoutCellInner = ({ value, config, id, style }) => {
        const [noupdates, setNoupdates] = useState(true);

        useEffect(() => {
          setNoupdates(false);
          const t = setTimeout(() => setNoupdates(true), 2000);
          return () => clearTimeout(t);
        }, [value]);

        if (!config) return null;
        const C = components[config.type];
        if (!C) return null;

        return (
          <div
            className={
              "layout-input layout-input-component-" +
              config.type +
              (noupdates ? " layout-input-noupdates" : "")
            }
            key={id}
          >
            <C value={value} config={config} id={id} style={style} />
          </div>
        );
      };

      const LayoutCell = React.memo(LayoutCellInner);

      const Layout = ({ direction, config, state, layout }) => {
        return (
          <div
            style={{
              display: "flex",
              flexDirection: direction,
              justifyContent:
                (config.style && config.style.spacing) || "space-between",
            }}
          >
            {layout.map((id) => {
              if (typeof id === "object" && Array.isArray(id)) {
                return (
                  <Layout
                    direction={direction === "column" ? "row" : "column"}
                    key={id}
                    config={config}
                    state={state}
                    layout={id}
                  />
                );
              }
              const input = config.inputs[id];
              return (
                <LayoutCell
                  key={id}
                  value={state[id]}
                  config={input}
                  id={id}
                  style={config.style}
                />
              );
            })}
          </div>
        );
      };

      function sample(array) {
        if (!array) return "";
        return array[Math.floor(array.length * Math.random())];
      }
      function mix(a, b, x) {
        return a * (1 - x) + b * x;
      }
      function lerp(a, b, x) {
        return (x - a) / (b - a);
      }

      function commandValueExample(conf, k) {
        switch (conf.type) {
          case "KeyboardCurve":
            return "any letter will shape the curve " + k;
          case "Poll":
            return "!" + k + " " + sample(Object.keys(conf.choices));
          case "Range":
            return (
              "!" +
              k +
              " " +
              (Math.random() < 0.3
                ? sample(["min", "mid", "max"])
                : Math.random() < 0.3
                ? (100 * Math.random()).toFixed(0) + "%"
                : mix(conf.min, conf.max, Math.random()).toFixed(
                    typeof conf.magnitude === "number" ? conf.magnitude : 1
                  ))
            );
          default:
            return "";
        }
      }

      function existsInLayout(layout, id) {
        for (let i = 0; i < layout.length; i++) {
          if (layout[i] === id) return true;
          if (Array.isArray(layout[i])) {
            if (existsInLayout(layout[i], id)) return true;
          }
        }
        return false;
      }

      const Styles = ({ config }) => {
        const style = { ...config.style };
        const dustColor = style.dustColor || "#68c0ff";
        const disabledColor = style.disabledColor || "#43778a";
        return (
          <style>{`:root {
        --color-main: ${style.colorMain || "#0ab1f0"};
        --color-live: ${style.colorLive || "#f00a0a"};
        --bg: ${style.bg || "radial-gradient(circle, #092643, #0c151c)"};
        --camera-highlight: radial-gradient(circle, ${dustColor}08, ${dustColor}7e);
        /* too much repetition here... */
        --color-disabled: ${disabledColor};
        --camera-highlight-disabled: radial-gradient(
          circle,
          ${disabledColor}98,
          ${disabledColor}d9
        );
      }`}</style>
        );
      };

      function useRefresh(ms) {
        const [t, setT] = useState(0);
        useEffect(() => {
          const i = setInterval(() => setT((t) => t + 1), ms);
          return () => clearInterval(i);
        }, [ms]);
        return t;
      }

      const DebugPreview = () => {
        const t = useRefresh(1000);
        return (
          <img
            className="debug-preview"
            src={`/all.svg?t=${t}`}
            id="predictive"
          />
        );
      };

      const Render = ({ state }) => {
        const config = state.config;
        const { plotting, prediction, index, total, countdownPause } =
          state.artServer;
        const percent = index / total;

        const layout = useMemo(() => {
          return config.layout || Object.keys(config.inputs);
        }, [config.layout]);

        return (
          <div className={"mode-" + state.rootState.mode}>
            <Styles config={config} />
            <div id="background"></div>
            <div
              id="plot-camera"
              className={
                "camera" +
                (state.artServer.started ? "" : " disabled") +
                (countdownPause ? " countdownpause" : "")
              }
            >
              {countdownPause
                ? [
                    <span key="title" className="countdown-pause-text">
                      {countdownPause.text}
                    </span>,
                    <Countdown key="timer" {...countdownPause} />,
                  ]
                : null}

              {config.debug ? (
                <DebugPreview />
              ) : (
                <img
                  className={config.predictive}
                  src={`/predictive.svg?t=${prediction}`}
                  id="predictive"
                />
              )}
              {state.artServer.started ? (
                <CamTimer relativeSince={state.artServer.startedTime} />
              ) : null}
            </div>
            <div key="footer" id="footer">
              <span>{state.config.title}</span>
            </div>
            <div id="plot-progress">
              <div className="progress-bar">
                <div
                  id="plot-progress-inner"
                  className="progress dashed"
                  style={{ width: (percent * 100).toFixed(1) + "%" }}
                ></div>
              </div>
            </div>
            <div id="streamer-camera" className="camera">
              <span className="live">
                <span className="blink">⏺</span>
                {" twitch.tv/greweb"}
              </span>
              <CamTimer absolute />
            </div>
            <div
              id="pen-camera"
              className={
                "camera " + (state.artServer.plotting ? "" : "disabled")
              }
            >
              {state.artServer.plotting ? (
                <CamTimer relativeSince={state.artServer.plottingTime} />
              ) : null}
            </div>
            <div id="chatbox">
              <ChatBox />
            </div>
            <div id="instructions">
              <div className="content">
                {Object.keys(config.inputs)
                  .filter((k) => existsInLayout(config.layout, k))
                  .map((k) =>
                    (commandValueExample(config.inputs[k], k) + "   ").padEnd(
                      20,
                      " "
                    )
                  )
                  .join("")}
              </div>
            </div>
            <div id="components">
              <Layout
                direction="column"
                config={config}
                state={state}
                layout={layout}
              />
            </div>
          </div>
        );
      };

      const Root = () => {
        const [state, setState] = useState(null);

        useEffect(() => {
          function reconnectLoop() {
            const eventSource = new EventSource("/stream/state");
            eventSource.onmessage = (e) => {
              console.log("RELOAD");
              location.href = "/";
              eventSource.close();
            };
            eventSource.onerror = (e) => {
              eventSource.close();
              setTimeout(reconnectLoop, 1000);
            };
          }

          const source = new EventSource("/stream/state");
          source.onmessage = (e) => {
            console.log(e.data);
            setState((prev) => ({ ...prev, ...JSON.parse(e.data) }));
          };
          source.onerror = (e) => {
            console.log("DISCONNECT");
            setTimeout(reconnectLoop, 1000);
            source.close();
          };
        }, []);

        if (!state) return null;

        return <Render state={state} />;
      };

      const CamTimer = ({ relativeSince }) => {
        const timerRef = useRef();

        useEffect(() => {
          if (relativeSince) {
            const updateTime = () => {
              if (!timerRef.current) return;
              const elapsedTime = (Date.now() - relativeSince) / 1000;
              const minutes = Math.floor(elapsedTime / 60);
              const seconds = elapsedTime % 60;
              timerRef.current.textContent = `${
                (minutes < 10 ? "0" : "") + minutes
              }:${(seconds < 10 ? "0" : "") + seconds.toFixed(2)}`;
              requestAnimationFrame(updateTime);
            };
            updateTime();
          } else {
            const updateTime = () => {
              if (!timerRef.current) return;
              const absoluteTime = new Date();
              const year = absoluteTime.getFullYear();
              const month = absoluteTime.getMonth() + 1;
              const day = absoluteTime.getDate();
              const hours = absoluteTime.getHours();
              const minutes = absoluteTime.getMinutes();
              const seconds = absoluteTime.getSeconds();
              timerRef.current.textContent = `${year}-${month}-${day} ${
                (hours < 10 ? "0" : "") + hours
              }:${(minutes < 10 ? "0" : "") + minutes}:${
                (seconds < 10 ? "0" : "") + seconds
              }`;
            };
            const timerId = setInterval(updateTime, 1000);
            updateTime();
            return () => {
              if (timerId) {
                clearInterval(timerId);
              }
            };
          }
        }, [relativeSince]);

        return <div className="camtimer" ref={timerRef} />;
      };

      const Countdown = ({ duration, startedTime }) => {
        const timerRef = useRef();

        useEffect(() => {
          const updateTime = () => {
            if (!timerRef.current) return;
            const time = duration - (Date.now() - startedTime) / 1000;
            const minutes = Math.floor(time / 60);
            const seconds = time % 60;
            timerRef.current.textContent =
              time <= 0
                ? ""
                : `${(minutes < 10 ? "0" : "") + minutes}:${
                    (seconds < 10 ? "0" : "") + seconds.toFixed(2)
                  }`;
            requestAnimationFrame(updateTime);
          };
          updateTime();
        }, [duration, startedTime]);

        return <div className="countdown" ref={timerRef} />;
      };

      function ChatBox() {
        const [messages, setMessages] = useState([]);
        const messagesEndRef = useRef(null);

        useEffect(() => {
          function connect() {
            const eventSource = new EventSource("/chatbox/messages");
            eventSource.onmessage = (e) => {
              const message = JSON.parse(e.data);
              setMessages((prevMessages) =>
                prevMessages.length >= 50
                  ? prevMessages.slice(1).concat(message)
                  : prevMessages.concat(message)
              );
            };
            eventSource.onerror = (e) => {
              eventSource.close();
            };
            return () => eventSource.close();
          }
          return connect();
        }, []);

        useEffect(() => {
          messagesEndRef.current.scrollIntoView({ behavior: "smooth" });
        }, [messages]);

        useEffect(() => {
          // Add the data-fade-out attribute to the messages after 5 seconds
          const timeoutIds = messages.map((_, index) =>
            setTimeout(() => {
              const messageElement = document.querySelector(
                `li:nth-child(${index + 1})`
              );
              if (messageElement) {
                messageElement.setAttribute("data-fade-out", "true");
              }
            }, 5000)
          );

          return () => {
            // Clear the timeout IDs when the component unmounts
            timeoutIds.forEach((timeoutId) => clearTimeout(timeoutId));
          };
        }, [messages]);

        return (
          <div className="chat">
            <ul>
              {messages.map((message, index) => (
                <li key={index}>
                  <b>{message.user}:</b> {message.text}
                </li>
              ))}
              <div ref={messagesEndRef} />
            </ul>
          </div>
        );
      }

      ReactDOM.createRoot(document.getElementById("main")).render(<Root />);
    </script>
  </body>
</html>
